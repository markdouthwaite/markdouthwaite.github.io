 This can give _dramatic_ speed boosts to your erstwhile sluggish Python code. 

<!-- In this post, I'm going to give a brief overview of what Cython is, and how it can be used to boost the performance of your pure Python code with relatively little effort. The code for this post is available [here](https://github.com/markdouthwaite/cython-examples). First off, what is Cython? Cython is a compiler for both Python and the Cython programming language. The Cython programming language is a near-complete superset of Python itself. Practically, this means that almost all Python code is valid Cython code â€“ you can generally drop your Python code into the Cython compiler and have it work straight out-of-the-box.

This raises an important distinction with respect to a normal Python workflow: to run Cythonised code, you will need to explicitly compile your Cython modules, first to C or C++, and then to binaries. The benefit of this compilation step is that Cython can optimise your Python or Cython modules at compile time, often dramatically improving the performance of your Python code at runtime. The Cython language also allows us to _optionally_ use static types in our Cython modules. Making use of extended features such as this can further boost the performance of a given module, though for those unfamiliar with statically typed languages, this may get a bit fiddly.

Finally, while the Cython compiler allows us to write modules using the Python and Cython languages as we choose, it also allows us to write C or C++ code and directly interface this code with our pure Python modules too. A future post will cover how you can do this, but suffice it to say -- this can come in very handy if you need to access C or C++ speed and/or functionality from Python. This means you can also do GPU programming in C/C++ with CUDA, and access this code from your user-friendly Python package. -->